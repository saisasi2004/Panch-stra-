<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PanchƒÅstra</title>
    <link rel="icon" href="robot.png" type="image">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #00c6ff;
            --secondary: #0072ff;
            --accent: #ff4d4d;
            --dark: #1a1a2e;
            --light: #f8f9fa;
            --success: #28a745;
            --warning: #ffc107;
            --danger: #dc3545;
            --info: #17a2b8;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(135deg, var(--dark) 0%, #16213e 100%);
            min-height: 100vh;
            color: var(--light);
            overflow-x: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
            gap: 20px;
            padding: 20px;
        }

        .control-panel {
            flex: 1;
            background: rgba(26, 26, 46, 0.8);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .visualization-panel {
            flex: 1.5;
            background: rgba(26, 26, 46, 0.8);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5em;
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 2px 10px rgba(0, 198, 255, 0.3);
            letter-spacing: 1px;
        }

        .panel-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
        }

        .panel-section:hover {
            border-color: rgba(0, 198, 255, 0.3);
            box-shadow: 0 5px 15px rgba(0, 198, 255, 0.1);
        }

        .section-title {
            font-size: 1.3em;
            font-weight: 500;
            margin-bottom: 15px;
            color: var(--primary);
            font-family: 'Orbitron', sans-serif;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-title i {
            font-size: 1.2em;
        }

        .connection-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        select, button, input {
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 1em;
            transition: all 0.3s ease;
            border: none;
            font-family: 'Roboto', sans-serif;
        }

        select, input[type="text"], input[type="number"] {
            background: rgba(255, 255, 255, 0.1);
            color: rgb(209, 206, 206);
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-width: 200px;
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(0, 198, 255, 0.2);
        }

        button {
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 500;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 198, 255, 0.4);
        }

        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        button:disabled::before {
            display: none;
        }

        .btn-success {
            background: linear-gradient(45deg, var(--success), #5cb85c);
        }

        .btn-warning {
            background: linear-gradient(45deg, var(--warning), #f0ad4e);
        }

        .btn-danger {
            background: linear-gradient(45deg, var(--danger), #d9534f);
        }

        .btn-info {
            background: linear-gradient(45deg, var(--info), #5bc0de);
        }

        .status {
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 500;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status::before {
            content: '';
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }

        .status.connected {
            background: rgba(40, 167, 69, 0.2);
            color: #d4edda;
        }

        .status.connected::before {
            background: #28a745;
        }

        .status.disconnected {
            background: rgba(220, 53, 69, 0.2);
            color: #f8d7da;
        }

        .status.disconnected::before {
            background: #dc3545;
        }

        .motor-controls {
            display: grid;
            gap: 20px;
        }

        .motor-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
        }

        .motor-group:hover {
            border-color: rgba(0, 198, 255, 0.3);
        }

        .motor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .motor-name {
            font-weight: 500;
            color: white;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .angle-display {
            background: rgba(0, 198, 255, 0.2);
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-weight: 500;
            min-width: 60px;
            text-align: center;
            font-family: 'Orbitron', sans-serif;
            border: 1px solid rgba(0, 198, 255, 0.3);
        }

        .slider-container {
            position: relative;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .slider:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 198, 255, 0.5);
            transition: all 0.3s ease;
            border: 2px solid white;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 15px rgba(0, 198, 255, 0.7);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 10px rgba(0, 198, 255, 0.5);
        }

        .gripper-controls {
            background: rgba(255, 77, 77, 0.05);
            border: 1px solid rgba(255, 77, 77, 0.1);
        }

        .gripper-controls:hover {
            border-color: rgba(255, 77, 77, 0.3);
        }

        .gripper-buttons {
            display: flex;
            gap: 15px;
            margin-top: 15px;
        }

        .gripper-btn {
            flex: 1;
            padding: 15px;
            font-size: 1.1em;
        }

        .open-btn {
            background: linear-gradient(45deg, var(--success), #5cb85c);
        }

        .close-btn {
            background: linear-gradient(45deg, var(--danger), #d9534f);
        }

        .visualization-title {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.5em;
            font-weight: 500;
            color: white;
            z-index: 10;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        #visualization {
            width: 100%;
            height: 100%;
            border-radius: 15px;
        }

        .range-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 5px;
        }

        .view-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            display: flex;
            gap: 10px;
        }

        .sequence-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .sequence-btn {
            flex: 1;
            min-width: 120px;
        }

        .ik-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .ik-input-group {
            display: flex;
            flex-direction: column;
        }

        .ik-input-group label {
            font-size: 0.8em;
            margin-bottom: 5px;
            color: rgba(255, 255, 255, 0.7);
        }

        .ik-go-btn {
            grid-column: span 3;
        }

        .coordinate-display {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 8px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            z-index: 10;
        }

        .target-marker {
            position: absolute;
            width: 10px;
            height: 10px;
            background: red;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 5;
        }

        @media (max-width: 1200px) {
            .container {
                flex-direction: column;
                height: auto;
            }
            
            .visualization-panel {
                height: 70vh;
            }

            .ik-controls {
                grid-template-columns: 1fr;
            }

            .ik-go-btn {
                grid-column: span 1;
            }
        }

        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        .status.connected {
            animation: pulse 2s infinite;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 100;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.9em;
            font-weight: normal;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(var(--primary), var(--secondary));
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="control-panel">
            <h1>PanchƒÅstra  (5-Axis Robotic Arm Controller)</h1>
            
            <div class="panel-section">
                <div class="section-title">
                    <span><b>COM</b> CONNECTION</span>
                </div>
                <div class="connection-controls">
                    <select id="portSelect">
                        <option value="">Select COM Port</option>
                    </select>
                    <button id="connectBtn"><span>Connect</span></button>
                    <button id="disconnectBtn" disabled><span>Disconnect</span></button>
                    <div id="connectionStatus" class="status disconnected"><span>Disconnected</span></div>
                </div>
            </div>

            <div class="panel-section">
                <div class="section-title">
                    <span>MOTOR CONTROLS</span>
                </div>
                <div class="motor-controls">
                    <div class="motor-group">
                        <div class="motor-header">
                            <div class="motor-name">Base Rotation (Motor 1)</div>
                            <div class="angle-display" id="angle1">90¬∞</div>
                        </div>
                        <div class="slider-container">
                            <input type="range" class="slider" id="motor1" min="0" max="180" value="90">
                            <div class="range-labels">
                                <span>0¬∞</span>
                                <span>90¬∞</span>
                                <span>180¬∞</span>
                            </div>
                        </div>
                    </div>

                    <div class="motor-group">
                        <div class="motor-header">
                            <div class="motor-name">Shoulder (Motor 2)</div>
                            <div class="angle-display" id="angle2">90¬∞</div>
                        </div>
                        <div class="slider-container">
                            <input type="range" class="slider" id="motor2" min="0" max="180" value="90">
                            <div class="range-labels">
                                <span>0¬∞</span>
                                <span>90¬∞</span>
                                <span>180¬∞</span>
                            </div>
                        </div>
                    </div>

                    <div class="motor-group">
                        <div class="motor-header">
                            <div class="motor-name">Elbow (Motor 3)</div>
                            <div class="angle-display" id="angle3">90¬∞</div>
                        </div>
                        <div class="slider-container">
                            <input type="range" class="slider" id="motor3" min="0" max="180" value="90">
                            <div class="range-labels">
                                <span>0¬∞</span>
                                <span>90¬∞</span>
                                <span>180¬∞</span>
                            </div>
                        </div>
                    </div>

                    <div class="motor-group">
                        <div class="motor-header">
                            <div class="motor-name">Wrist Pitch (Motor 4)</div>
                            <div class="angle-display" id="angle4">90¬∞</div>
                        </div>
                        <div class="slider-container">
                            <input type="range" class="slider" id="motor4" min="0" max="180" value="90">
                            <div class="range-labels">
                                <span>0¬∞</span>
                                <span>90¬∞</span>
                                <span>180¬∞</span>
                            </div>
                        </div>
                    </div>

                    <div class="motor-group">
                        <div class="motor-header">
                            <div class="motor-name">Wrist Roll (Motor 5)</div>
                            <div class="angle-display" id="angle5">90¬∞</div>
                        </div>
                        <div class="slider-container">
                            <input type="range" class="slider" id="motor5" min="0" max="180" value="90">
                            <div class="range-labels">
                                <span>0¬∞</span>
                                <span>90¬∞</span>
                                <span>180¬∞</span>
                            </div>
                        </div>
                    </div>

                    <div class="motor-group gripper-controls">
                        <div class="motor-header">
                            <div class="motor-name">Gripper Control</div>
                            <div class="angle-display" id="gripperAngle">0¬∞</div>
                        </div>
                        <div class="slider-container">
                            <input type="range" class="slider" id="gripper" min="0" max="180" value="0">
                            <div class="range-labels">
                                <span>Closed (0¬∞)</span>
                                <span>Open (180¬∞)</span>
                            </div>
                        </div>
                        <div class="gripper-buttons">
                            <button class="gripper-btn open-btn" id="openGripper">Open Gripper</button>
                            <button class="gripper-btn close-btn" id="closeGripper">Close Gripper</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <div class="section-title">
                    <span>INVERSE KINEMATICS</span>
                </div>
                <div class="ik-controls">
                    <div class="ik-input-group">
                        <label>X Position</label>
                        <input type="number" id="ikX" value="4.1" step="0.1" min="-5" max="5">
                    </div>
                    <div class="ik-input-group">
                        <label>Y Position</label>
                        <input type="number" id="ikY" value="2" step="0.1" min="0" max="5">
                    </div>
                    <div class="ik-input-group">
                        <label>Z Position</label>
                        <input type="number" id="ikZ" value="0" step="0.1" min="-5" max="5">
                    </div>
                    <button class="btn-info ik-go-btn" id="ikGoBtn">Move to Position</button>
                </div>
                <div class="tooltip" style="margin-top: 15px;">
                    <button class="btn-info" id="ikPickBtn">Pick from Visualization</button>
                    <span class="tooltiptext">Click this button then click in the 3D visualization to set target position</span>
                </div>
            </div>

            <div class="panel-section">
                <div class="section-title">
                    <span>MOTION SEQUENCES</span>
                </div>
                <div class="sequence-controls">
                    <button class="btn-success sequence-btn" id="recordBtn">Record Position</button>
                    <button class="btn-warning sequence-btn" id="playBtn">Play Sequence</button>
                    <button class="btn-info sequence-btn" id="saveBtn">Save Sequence</button>
                    <button class="btn-info sequence-btn" id="loadBtn">Load Sequence</button>
                    <button class="btn-danger sequence-btn" id="clearBtn">Clear Sequence</button>
                </div>
                <div id="sequenceList" style="margin-top: 15px; color: rgba(255, 255, 255, 0.8);">
                    No positions recorded yet
                </div>
            </div>
        </div>

        <div class="visualization-panel">
            <div class="visualization-title">ARM VISUALIZATION</div>
            <div class="view-controls">
                <button id="view360Btn">View 360</button>
                <button id="resetViewBtn">Reset View</button>
                <button id="helpBtn">HELP</button>
            </div>
            <div id="visualization"></div>
            <div class="coordinate-display" id="coordinateDisplay">
                End Effector: X: 0.00, Y: 0.00, Z: 0.00
            </div>
            <div class="target-marker" id="targetMarker" style="display: none;"></div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, arm = {};
        let serialPort = null;
        let isConnected = false;
        let isRotating = false;
        let isRecording = false;
        let isPickingPosition = false;
        let currentAngles = {
            motor1: 90, motor2: 90, motor3: 90, motor4: 90, motor5: 90, gripper: 0
        };
        let motionSequence = [];
        let endEffector = new THREE.Vector3();
        let targetPosition = new THREE.Vector3(2, 2, 0);
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        let targetMarker = document.getElementById('targetMarker');
        let sequencePlaying = false;
        let currentSequenceIndex = 0;
        let sequenceInterval;
        let animationFrameId;
        let gui = new dat.GUI({ width: 300 });
        let ikControls = {
            x: 4.1,
            y: 2,
            z: 0,
            speed: 1.0
        };
        let rotationStartTime = Date.now();

        document.addEventListener('DOMContentLoaded', function() {
            initializeVisualization();
            setupEventListeners();
            populateComPorts();
            animate();
            updateEndEffectorPosition();
            setupGUI();
        });

        function initializeVisualization() {
            const container = document.getElementById('visualization');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            const gridHelper = new THREE.GridHelper(10, 20, 0x444444, 0x222222);
            scene.add(gridHelper);

            const axesHelper = new THREE.AxesHelper(2);
            scene.add(axesHelper);

            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(7, 5, 5);
            camera.lookAt(0, 2, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(10, 10, 5);
            directionalLight1.castShadow = true;
            directionalLight1.shadow.mapSize.width = 2048;
            directionalLight1.shadow.mapSize.height = 2048;
            scene.add(directionalLight1);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight2.position.set(-5, 5, -5);
            scene.add(directionalLight2);
            
            const pointLight = new THREE.PointLight(0x00c6ff, 0.5, 10);
            pointLight.position.set(0, 3, 0);
            scene.add(pointLight);
            
            createRoboticArm();

            container.addEventListener('click', onVisualizationClick, false);
            
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        }

        function setupGUI() {
            while(gui.__controllers.length > 0) {
                gui.remove(gui.__controllers[0]);
            }

            gui.add(ikControls, 'x', -5, 5).name('X Position').onChange(updateTargetMarker);
            gui.add(ikControls, 'y', 0, 5).name('Y Position').onChange(updateTargetMarker);
            gui.add(ikControls, 'z', -5, 5).name('Z Position').onChange(updateTargetMarker);
            gui.add(ikControls, 'speed', 0.1, 2).name('Movement Speed');
            gui.add({calculate: () => calculateIK()}, 'calculate').name('Calculate IK');

            const seqFolder = gui.addFolder('Motion Sequences');
            seqFolder.add({record: () => toggleRecording()}, 'record').name('Record Position');
            seqFolder.add({play: () => playSequence()}, 'play').name('Play Sequence');
            seqFolder.add({save: () => saveSequence()}, 'save').name('Save Sequence');
            seqFolder.add({load: () => loadSequence()}, 'load').name('Load Sequence');
            seqFolder.add({clear: () => clearSequence()}, 'clear').name('Clear Sequence');

            gui.domElement.style.zIndex = 100;
            gui.domElement.style.position = 'absolute';
            gui.domElement.style.top = '20px';
            gui.domElement.style.left = '20px';
        }

        function createRoboticArm() {
            const baseGeometry = new THREE.CylinderGeometry(0.8, 1, 0.3, 16);
            const baseMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x333333,
                specular: 0x111111,
                shininess: 30
            });
            arm.base = new THREE.Mesh(baseGeometry, baseMaterial);
            arm.base.castShadow = true;
            arm.base.receiveShadow = true;
            scene.add(arm.base);

            const link1Geometry = new THREE.BoxGeometry(0.3, 2, 0.3);
            const link1Material = new THREE.MeshPhongMaterial({ 
                color: 0x00c6ff,
                specular: 0x0072ff,
                shininess: 50
            });
            arm.link1 = new THREE.Mesh(link1Geometry, link1Material);
            arm.link1.position.y = 1.15;
            arm.link1.castShadow = true;
            arm.link1.receiveShadow = true;
            arm.base.add(arm.link1);

            const joint1Geometry = new THREE.SphereGeometry(0.2, 16, 16);
            const jointMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff4d4d,
                specular: 0xff9999,
                shininess: 100
            });
            arm.joint1 = new THREE.Mesh(joint1Geometry, jointMaterial);
            arm.joint1.position.y = 1;
            arm.joint1.castShadow = true;
            arm.link1.add(arm.joint1);

            const link2Geometry = new THREE.BoxGeometry(0.25, 1.8, 0.25);
            const link2Material = new THREE.MeshPhongMaterial({ 
                color: 0x4ecdc4,
                specular: 0x2a9d8f,
                shininess: 50
            });
            arm.link2 = new THREE.Mesh(link2Geometry, link2Material);
            arm.link2.position.y = 0.9;
            arm.link2.castShadow = true;
            arm.link2.receiveShadow = true;
            arm.joint1.add(arm.link2);

            arm.joint2 = new THREE.Mesh(joint1Geometry, jointMaterial);
            arm.joint2.position.y = 0.9;
            arm.joint2.castShadow = true;
            arm.link2.add(arm.joint2);

            const link3Geometry = new THREE.BoxGeometry(0.2, 1.5, 0.2);
            const link3Material = new THREE.MeshPhongMaterial({ 
                color: 0xf7b731,
                specular: 0xf39c12,
                shininess: 50
            });
            arm.link3 = new THREE.Mesh(link3Geometry, link3Material);
            arm.link3.position.y = 0.75;
            arm.link3.castShadow = true;
            arm.link3.receiveShadow = true;
            arm.joint2.add(arm.link3);

            arm.joint3 = new THREE.Mesh(joint1Geometry, jointMaterial);
            arm.joint3.position.y = 0.75;
            arm.joint3.castShadow = true;
            arm.link3.add(arm.joint3);

            const link4Geometry = new THREE.BoxGeometry(0.15, 0.8, 0.15);
            const link4Material = new THREE.MeshPhongMaterial({ 
                color: 0xa55eea,
                specular: 0x7e4fcc,
                shininess: 50
            });
            arm.link4 = new THREE.Mesh(link4Geometry, link4Material);
            arm.link4.position.y = 0.4;
            arm.link4.castShadow = true;
            arm.link4.receiveShadow = true;
            arm.joint3.add(arm.link4);

            arm.joint4 = new THREE.Mesh(joint1Geometry, jointMaterial);
            arm.joint4.position.y = 0.4;
            arm.joint4.castShadow = true;
            arm.link4.add(arm.joint4);

            const gripperBaseGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.2, 8);
            const gripperBaseMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x26de81,
                specular: 0x10ac84,
                shininess: 50
            });
            arm.gripperBase = new THREE.Mesh(gripperBaseGeometry, gripperBaseMaterial);
            arm.gripperBase.position.y = 0.15;
            arm.gripperBase.castShadow = true;
            arm.gripperBase.receiveShadow = true;
            arm.joint4.add(arm.gripperBase);

            const fingerGeometry = new THREE.BoxGeometry(0.05, 0.3, 0.02);
            const fingerMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff,
                specular: 0x636e72,
                shininess: 30
            });
            
            arm.finger1 = new THREE.Mesh(fingerGeometry, fingerMaterial);
            arm.finger1.position.set(-0.08, 0.25, 0);
            arm.finger1.castShadow = true;
            arm.finger1.receiveShadow = true;
            arm.gripperBase.add(arm.finger1);
            
            arm.finger2 = new THREE.Mesh(fingerGeometry, fingerMaterial);
            arm.finger2.position.set(0.08, 0.25, 0);
            arm.finger2.castShadow = true;
            arm.finger2.receiveShadow = true;
            arm.gripperBase.add(arm.finger2);

            const endEffectorGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const endEffectorMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            arm.endEffectorIndicator = new THREE.Mesh(endEffectorGeometry, endEffectorMaterial);
            arm.joint4.add(arm.endEffectorIndicator);
        }

        function setupEventListeners() {
            for (let i = 1; i <= 5; i++) {
                const slider = document.getElementById(`motor${i}`);
                const angleDisplay = document.getElementById(`angle${i}`);
                
                slider.addEventListener('input', function() {
                    const angle = parseInt(this.value);
                    currentAngles[`motor${i}`] = angle;
                    angleDisplay.textContent = `${angle}¬∞`;
                    updateArmVisualization();
                    sendMotorData();
                    
                    if (isRecording) {
                        recordPosition();
                    }
                });
            }

            const gripperSlider = document.getElementById('gripper');
            const gripperAngleDisplay = document.getElementById('gripperAngle');
            
            gripperSlider.addEventListener('input', function() {
                const angle = parseInt(this.value);
                currentAngles.gripper = angle;
                gripperAngleDisplay.textContent = `${angle}¬∞`;
                updateGripperVisualization();
                sendMotorData();
                
                if (isRecording) {
                    recordPosition();
                }
            });
            
            document.getElementById('openGripper').addEventListener('click', function() {
                gripperSlider.value = 180;
                currentAngles.gripper = 180;
                gripperAngleDisplay.textContent = '180¬∞';
                updateGripperVisualization();
                sendMotorData();
                
                if (isRecording) {
                    recordPosition();
                }
            });
            
            document.getElementById('closeGripper').addEventListener('click', function() {
                gripperSlider.value = 0;
                currentAngles.gripper = 0;
                gripperAngleDisplay.textContent = '0¬∞';
                updateGripperVisualization();
                sendMotorData();
                
                if (isRecording) {
                    recordPosition();
                }
            });

            document.getElementById('connectBtn').addEventListener('click', connectSerial);
            document.getElementById('disconnectBtn').addEventListener('click', disconnectSerial);

            document.getElementById('view360Btn').addEventListener('click', toggle360View);
            document.getElementById('resetViewBtn').addEventListener('click', resetView);

            document.getElementById('ikGoBtn').addEventListener('click', calculateIK);
            document.getElementById('ikPickBtn').addEventListener('click', togglePositionPicking);

            document.getElementById('recordBtn').addEventListener('click', toggleRecording);
            document.getElementById('playBtn').addEventListener('click', playSequence);
            document.getElementById('saveBtn').addEventListener('click', saveSequence);
            document.getElementById('loadBtn').addEventListener('click', loadSequence);
            document.getElementById('clearBtn').addEventListener('click', clearSequence);
        }

        function toggle360View() {
            if (isRotating) {
                isRotating = false;
                document.getElementById('view360Btn').textContent = 'View 360';
            } else {
                isRotating = true;
                rotationStartTime = Date.now();
                document.getElementById('view360Btn').textContent = 'Stop 360';
            }
        }

        function resetView() {
            isRotating = false;
            document.getElementById('view360Btn').textContent = 'View 360';
            camera.position.set(7, 5, 5);
            camera.lookAt(0, 2, 0);
        }

        function populateComPorts() {
            const portSelect = document.getElementById('portSelect');
            const mockPorts = ['Select COM PORTs'];
            
            mockPorts.forEach(port => {
                const option = document.createElement('option');
                option.value = port;
                option.textContent = port;
                portSelect.appendChild(option);
            });
        }

        async function connectSerial() {
            const selectedPort = document.getElementById('portSelect').value;
            
            if (!selectedPort) {
                showNotification('Please select a COM port first!', 'warning');
                return;
            }

            if ('serial' in navigator) {
                try {
                    serialPort = await navigator.serial.requestPort();
                    await serialPort.open({ baudRate: 9600 });
                    isConnected = true;
                    updateConnectionStatus(true);

                    showNotification('Connected successfully!', 'success');
                } catch (error) {
                    console.error('Serial connection failed:', error);
                    showNotification('Connection failed!', 'error');
                }
            } else {
                console.log(`Simulating connection to ${selectedPort}`);
                isConnected = true;
                updateConnectionStatus(true);
                showNotification(`Simulated connection to ${selectedPort}`, 'info');
            }
        }

        async function disconnectSerial() {
            if (serialPort) {
                try {
                    await serialPort.close();
                    serialPort = null;
                    isConnected = false;
                    updateConnectionStatus(false);
                    showNotification('Disconnected successfully', 'info');
                } catch (error) {
                    console.error('Error disconnecting:', error);
                    showNotification('Error disconnecting', 'error');
                }
            } else {
                isConnected = false;
                updateConnectionStatus(false);
                showNotification('Disconnected', 'info');
            }
        }

        function updateConnectionStatus(connected) {
            const statusElement = document.getElementById('connectionStatus');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            
            if (connected) {
                statusElement.textContent = 'Connected';
                statusElement.className = 'status connected';
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
            } else {
                statusElement.textContent = 'Disconnected';
                statusElement.className = 'status disconnected';
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
            }
        }

        async function sendMotorData() {
            if (!isConnected) return;
            
            const data = `M1:${currentAngles.motor1},M2:${currentAngles.motor2},M3:${currentAngles.motor3},M4:${currentAngles.motor4},M5:${currentAngles.motor5},G:${currentAngles.gripper}\n`;
            
            if (serialPort && serialPort.writable) {
                const writer = serialPort.writable.getWriter();
                try {
                    await writer.write(new TextEncoder().encode(data));
                } catch (error) {
                    console.error('Failed to send data:', error);
                    showNotification('Failed to send data', 'error');
                } finally {
                    writer.releaseLock();
                }
            } else {
                console.log('Serial data:', data);
            }
        }

        function updateArmVisualization() {
            if (!arm.base) return;

            const deg2rad = Math.PI / 180;

            arm.base.rotation.y = currentAngles.motor1 * deg2rad;
            arm.joint1.rotation.z = -(currentAngles.motor2 - 90) * deg2rad;
            arm.joint2.rotation.z = -(currentAngles.motor3 - 90) * deg2rad;
            arm.joint3.rotation.z = -(currentAngles.motor4 - 90) * deg2rad;
            arm.joint4.rotation.y = (currentAngles.motor5 - 90) * deg2rad;

            updateEndEffectorPosition();
        }

        function updateGripperVisualization() {
            if (!arm.finger1 || !arm.finger2) return;
            
            const gripperAngle = currentAngles.gripper;
            const maxSpread = 0.12;
            const currentSpread = (gripperAngle / 90) * maxSpread;
            
            arm.finger1.position.x = -0.08 - currentSpread;
            arm.finger2.position.x = 0.08 + currentSpread;
        }

        function updateEndEffectorPosition() {
            const deg2rad = Math.PI / 180;
            const l1 = 2;  // Length of link 1
            const l2 = 1.8; // Length of link 2
            const l3 = 1.5; // Length of link 3
            const l4 = 0.8; // Length of link 4
            
            const theta1 = currentAngles.motor1 * deg2rad;
            const theta2 = (currentAngles.motor2 - 90) * deg2rad;
            const theta3 = (currentAngles.motor3 - 90) * deg2rad;
            const theta4 = (currentAngles.motor4 - 90) * deg2rad;
            const theta5 = (currentAngles.motor5 - 90) * deg2rad;

            endEffector.set(
                Math.sin(theta1) * (l2 * Math.cos(theta2) + l3 * Math.cos(theta2 + theta3) + l4 * Math.cos(theta2 + theta3 + theta4)),
                l1 + l2 * Math.sin(theta2) + l3 * Math.sin(theta2 + theta3) + l4 * Math.sin(theta2 + theta3 + theta4),
                Math.cos(theta1) * (l2 * Math.cos(theta2) + l3 * Math.cos(theta2 + theta3) + l4 * Math.cos(theta2 + theta3 + theta4))
            );

            document.getElementById('coordinateDisplay').textContent = 
                `End Effector: X: ${endEffector.x.toFixed(2)}, Y: ${endEffector.y.toFixed(2)}, Z: ${endEffector.z.toFixed(2)}`;
        }

        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            
            if (isRotating) {
                const time = (Date.now() - rotationStartTime) * 0.001;
                camera.position.x = Math.cos(time * 0.5) * 8;
                camera.position.z = Math.sin(time * 0.5) * 8;
                camera.lookAt(0, 2, 0);
            }
            
            renderer.render(scene, camera);
        }

        function calculateIK() {
            targetPosition.set(
                parseFloat(document.getElementById('ikX').value),
                parseFloat(document.getElementById('ikY').value),
                parseFloat(document.getElementById('ikZ').value)
            );

            const l1 = 2;   // Height of base
            const l2 = 1.8; // Length of upper arm
            const l3 = 1.5; // Length of forearm
            const l4 = 0.8; // Length from wrist to gripper (end effector)

            // 1. Calculate base rotation (Œ∏‚ÇÅ)
            const theta1 = Math.atan2(targetPosition.x, targetPosition.z);

            // 2. Calculate the direction from base to target in XZ plane
            const distanceXZ = Math.sqrt(targetPosition.x * targetPosition.x + targetPosition.z * targetPosition.z);

            // 3. Use the target position directly as the end effector (no wrist offset)
            const wristX = targetPosition.x;
            const wristY = targetPosition.y;
            const wristZ = targetPosition.z;

            // 4. Calculate distance in the arm plane (XZ) to end effector
            const wristDistance = Math.sqrt(wristX * wristX + wristZ * wristZ);
            const adjY = wristY - l1;
            const adjDistance = wristDistance;

            // 5. Calculate shoulder (Œ∏‚ÇÇ) and elbow (Œ∏‚ÇÉ) angles using law of cosines
            const D = (adjDistance * adjDistance + adjY * adjY - l2 * l2 - (l3 + l4) * (l3 + l4)) / (2 * l2 * (l3 + l4));

            if (Math.abs(D) > 1) {
                showNotification('Target position unreachable!', 'error');
                return;
            }

            const theta3 = Math.atan2(-Math.sqrt(1 - D * D), D);
            const theta2 = Math.atan2(adjY, adjDistance) - Math.atan2((l3 + l4) * Math.sin(theta3), l2 + (l3 + l4) * Math.cos(theta3));

            // 6. Set wrist pitch (Œ∏‚ÇÑ) to keep gripper level
            const theta4 = - (theta2 + theta3);

            const newAngles = {
                motor1: theta1 * (180 / Math.PI),
                motor2: 90 + theta2 * (180 / Math.PI),
                motor3: 90 + theta3 * (180 / Math.PI),
                motor4: 90 + theta4 * (180 / Math.PI),
                motor5: 90
            };

            animateToPosition(newAngles);
            updateTargetMarker();
        }
        
        function animateToPosition(targetAngles, duration = 250) {
            const startAngles = {...currentAngles};
            const startTime = Date.now();
            
            function update() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                for (const motor in targetAngles) {
                    if (targetAngles.hasOwnProperty(motor)) {
                        currentAngles[motor] = startAngles[motor] + 
                            (targetAngles[motor] - startAngles[motor]) * progress;
                        
                        const slider = document.getElementById(motor);
                        if (slider) {
                            slider.value = currentAngles[motor];
                            const angleDisplay = document.getElementById(motor === 'gripper' ? 'gripperAngle' : `angle${motor.slice(5)}`);
                            if (angleDisplay) {
                                angleDisplay.textContent = `${Math.round(currentAngles[motor])}¬∞`;
                            }
                        }
                    }
                }
                
                updateArmVisualization();
                updateGripperVisualization();
                sendMotorData();
                
                if (progress < 1) {
                    requestAnimationFrame(update);
                }
            }
            
            update();
        }

        function togglePositionPicking() {
            isPickingPosition = !isPickingPosition;
            const btn = document.getElementById('ikPickBtn');
            
            if (isPickingPosition) {
                btn.classList.add('active');
                btn.innerHTML = 'Click in Visualization';
                showNotification('Click in the 3D view to set target position', 'info');
            } else {
                btn.classList.remove('active');
                btn.innerHTML = 'Pick from Visualization';
            }
        }

        function onVisualizationClick(event) {
            if (!isPickingPosition) return;

            const container = document.getElementById('visualization');
            const rect = container.getBoundingClientRect();

            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersection = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersection);

            if (intersection) {
                targetPosition.set(intersection.x, intersection.y, intersection.z);

                document.getElementById('ikX').value = intersection.x.toFixed(2);
                document.getElementById('ikY').value = intersection.y.toFixed(2);
                document.getElementById('ikZ').value = intersection.z.toFixed(2);

                ikControls.x = intersection.x;
                ikControls.y = intersection.y;
                ikControls.z = intersection.z;
                gui.updateDisplay?.(); 

                updateTargetMarker();

                showNotification(`Target set to X: ${intersection.x.toFixed(2)}, Y: ${intersection.y.toFixed(2)}, Z: ${intersection.z.toFixed(2)}`, 'success');

                calculateIK();
            }

            isPickingPosition = false;
            document.getElementById('ikPickBtn').classList.remove('active');
            document.getElementById('ikPickBtn').innerHTML = 'Pick from Visualization';
        }

        function updateTargetMarker() {
            const container = document.getElementById('visualization');
            const rect = container.getBoundingClientRect();
            
            targetPosition.set(
                parseFloat(document.getElementById('ikX').value),
                parseFloat(document.getElementById('ikY').value),
                parseFloat(document.getElementById('ikZ').value)
            );
            
            const vector = targetPosition.clone().project(camera);
            
            const x = (vector.x * 0.5 + 0.5) * rect.width + rect.left;
            const y = -(vector.y * 0.5 - 0.5) * rect.height + rect.top;
            
            targetMarker.style.display = 'block';
            targetMarker.style.left = `${x}px`;
            targetMarker.style.top = `${y}px`;
        }

        function toggleRecording() {
            isRecording = !isRecording;
            const btn = document.getElementById('recordBtn');
            
            if (isRecording) {
                btn.classList.add('active');
                btn.innerHTML = 'Recording...';
                showNotification('Recording arm position', 'info');
            } else {
                btn.classList.remove('active');
                btn.innerHTML = 'Record Position';
            }
        }

        function recordPosition() {
            if (!isRecording) return;
            
            const position = {
                angles: {...currentAngles},
                timestamp: Date.now()
            };
            
            motionSequence.push(position);
            updateSequenceList();
            showNotification(`Position recorded (${motionSequence.length})`, 'success');
        }

        function updateSequenceList() {
            const listElement = document.getElementById('sequenceList');
            
            if (motionSequence.length === 0) {
                listElement.innerHTML = 'No positions recorded yet';
                return;
            }
            
            let html = '<div style="max-height: 150px; overflow-y: auto;">';
            motionSequence.forEach((pos, index) => {
                html += `<div style="padding: 5px; border-bottom: 1px solid rgba(255,255,255,0.1);">
                    Position ${index + 1}: 
                    M1: ${pos.angles.motor1}¬∞, 
                    M2: ${pos.angles.motor2}¬∞, 
                    M3: ${pos.angles.motor3}¬∞, 
                    M4: ${pos.angles.motor4}¬∞, 
                    M5: ${pos.angles.motor5}¬∞, 
                    G: ${pos.angles.gripper}¬∞
                </div>`;
            });
            html += '</div>';
            
            listElement.innerHTML = html;
        }

        function playSequence() {
            if (sequencePlaying || motionSequence.length === 0) return;
            
            sequencePlaying = true;
            currentSequenceIndex = 0;
            document.getElementById('playBtn').disabled = true;
            document.getElementById('playBtn').innerHTML = 'Playing...';
            
            showNotification('Playing motion sequence', 'info');
            
            function playNextPosition() {
                if (currentSequenceIndex >= motionSequence.length) {
                    sequencePlaying = false;
                    document.getElementById('playBtn').disabled = false;
                    document.getElementById('playBtn').innerHTML = 'Play Sequence';
                    showNotification('Sequence completed', 'success');
                    return;
                }
                
                const position = motionSequence[currentSequenceIndex];
                animateToPosition(position.angles, 250 / ikControls.speed);
                
                currentSequenceIndex++;
                setTimeout(playNextPosition, 10 / ikControls.speed);
            }
            
            playNextPosition();
        }

        function saveSequence() {
            if (motionSequence.length === 0) {
                showNotification('No positions to save', 'warning');
                return;
            }
            
            const sequenceData = JSON.stringify(motionSequence);
            const blob = new Blob([sequenceData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `arm_sequence_${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('Sequence saved', 'success');
        }

        function loadSequence() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = e => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = event => {
                    try {
                        motionSequence = JSON.parse(event.target.result);
                        updateSequenceList();
                        showNotification(`Loaded sequence with ${motionSequence.length} positions`, 'success');
                    } catch (error) {
                        console.error('Error loading sequence:', error);
                        showNotification('Error loading sequence file', 'error');
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        function clearSequence() {
            if (motionSequence.length === 0) {
                showNotification('Sequence already empty', 'warning');
                return;
            }
            
            if (confirm('Are you sure you want to clear the motion sequence?')) {
                motionSequence = [];
                updateSequenceList();
                showNotification('Sequence cleared', 'info');
            }
        }

        function showNotification(message, type) {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.classList.add('fade-out');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 500);
            }, 3000);
        }

        const style = document.createElement('style');
        style.textContent = `
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            transform: translateX(100%);
            opacity: 0;
            animation: slideIn 0.5s forwards;
        }

        .notification.success {
            background: linear-gradient(45deg, #28a745, #5cb85c);
        }

        .notification.error {
            background: linear-gradient(45deg, #dc3545, #d9534f);
        }

        .notification.info {
            background: linear-gradient(45deg, #17a2b8, #5bc0de);
        }

        .notification.warning {
            background: linear-gradient(45deg, #ffc107, #f0ad4e);
        }

        .fade-out {
            animation: fadeOut 0.5s forwards;
        }

        @keyframes slideIn {
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
                transform: translateX(100%);
            }
        }
        `;
        document.head.appendChild(style);
        for (let i = 1; i <= 5; i++) {
            const slider = document.getElementById(`motor${i}`);
            slider.addEventListener('change', function() {
                if (isRecording) {
                    recordPosition();
                }
            });
        }

        document.getElementById('gripper').addEventListener('change', function() {
            if (isRecording) {
                recordPosition();
            }
        });

        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey && event.key === 's') {
                event.preventDefault();
                saveSequence();
            }
            else if (event.ctrlKey && event.key === 'l') {
                event.preventDefault();
                loadSequence();
            }
            else if (event.key === ' ' && !event.target.matches('input, select, textarea')) {
                event.preventDefault();
                toggleRecording();
            }
        });

        async function checkSerialConnection() {
            if (!serialPort) return false;
            
            try {
                const writer = serialPort.writable.getWriter();
                writer.releaseLock();
                return true;
            } catch (error) {
                console.error('Serial connection check failed:', error);
                isConnected = false;
                updateConnectionStatus(false);
                showNotification('Serial connection lost', 'error');
                return false;
            }
        }

        setInterval(async () => {
            if (isConnected) {
                const stillConnected = await checkSerialConnection();
                if (!stillConnected) {
                    isConnected = false;
                    updateConnectionStatus(false);
                }
            }
        }, 5000);

        document.addEventListener('keydown', function(event) {
            if (event.key === 'E' || event.key === 'e') {
                emergencyStop();
            }
        });

        function emergencyStop() {
            const safeAngles = {
                motor1: 90,
                motor2: 90,
                motor3: 90,
                motor4: 90,
                motor5: 90,
                gripper: 0
            };
            
            cancelAnimationFrame(animationFrameId);

            for (const motor in safeAngles) {
                currentAngles[motor] = safeAngles[motor];
                const slider = document.getElementById(motor);
                if (slider) {
                    slider.value = safeAngles[motor];
                    const angleDisplay = document.getElementById(motor === 'gripper' ? 'gripperAngle' : `angle${motor.slice(5)}`);
                    if (angleDisplay) {
                        angleDisplay.textContent = `${safeAngles[motor]}¬∞`;
                    }
                }
            }

            updateArmVisualization();
            updateGripperVisualization();

            if (isConnected) {
                sendMotorData();
            }

            if (sequencePlaying) {
                clearTimeout(sequenceInterval);
                sequencePlaying = false;
                document.getElementById('playBtn').disabled = false;
                document.getElementById('playBtn').innerHTML = 'Play Sequence';
            }
            
            showNotification('EMERGENCY STOP ACTIVATED', 'error');
        }

        document.getElementById('helpBtn').addEventListener('click', function() {
            const helpDialog = document.createElement('div');
            helpDialog.className = 'help-dialog';
            helpDialog.innerHTML = `
                <div class="help-content">
                    <h3>Robotic Arm Controller Help</h3>
                    <ul>
                        <li><strong>Motor Controls:</strong> Use sliders to control each joint</li>
                        <li><strong>Gripper:</strong> Use slider or buttons to open/close</li>
                        <li><strong>Inverse Kinematics:</strong> Set target position or pick from 3D view</li>
                        <li><strong>Sequences:</strong> Record, play, save and load motion sequences</li>
                        <li><strong>Shortcuts:</strong> Space to record, Ctrl+S to save, Ctrl+L to load, E to emergency stop</li>
                    </ul>
                    <button class="close-help">Close</button>
                </div>
            `;
            
            document.body.appendChild(helpDialog);
            
            const helpStyle = document.createElement('style');
            helpStyle.textContent = `
                .help-dialog {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                }
                .help-content {
                    background: var(--dark);
                    padding: 30px;
                    border-radius: 15px;
                    max-width: 600px;
                    border: 1px solid var(--primary);
                }
                .help-content h3 {
                    color: var(--primary);
                    margin-bottom: 20px;
                    font-family: 'Orbitron', sans-serif;
                }
                .help-content ul {
                    margin-bottom: 20px;
                    padding-left: 20px;
                }
                .help-content li {
                    margin-bottom: 10px;
                    line-height: 1.6;
                }
                .close-help {
                    background: var(--primary);
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: 500;
                }
            `;
            document.head.appendChild(helpStyle);
                helpDialog.querySelector('.close-help').addEventListener('click', function() {
                document.body.removeChild(helpDialog);
                document.head.removeChild(helpStyle);
            });
        });

        window.onload = function() {
            updateArmVisualization();
            updateGripperVisualization();
            
            if (!document.getElementById('helpBtn')) {
                const helpBtn = document.createElement('button');
                helpBtn.id = 'helpBtn';
                helpBtn.className = 'btn-info';
                helpBtn.style.position = 'fixed';
                helpBtn.style.bottom = '20px';
                helpBtn.style.right = '20px';
                helpBtn.style.zIndex = '100';
                helpBtn.textContent = 'Help';
                document.body.appendChild(helpBtn);
                }
                };
    </script>
</body>
</html>
